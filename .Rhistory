pdf_compiler_ui <- function(id) {
ns <- NS(id)
tagList(
h3("PDF Compiler"),
radioButtons(
ns("source_mode"), "Choose source",
c("Server folder" = "folder", "Upload ZIP" = "zip"),
inline = TRUE
),
fluidRow(
conditionalPanel(
condition = sprintf("input['%s'] == 'folder'", ns("source_mode")),
column(
12,
textInput(
ns("pdf_dir"),
"Absolute folder path (server):",
placeholder = "e.g., /srv/data/T3ERESA"
),
helpText("Folder must contain files like 0.pdf, 1.pdf, 1p.pdf, 2.pdf, 2p.pdf, ...")
)
),
conditionalPanel(
condition = sprintf("input['%s'] == 'zip'", ns("source_mode")),
column(
12,
fileInput(
ns("zipfile"),
"Upload a ZIP containing your PDFs (filenames like 0.pdf, 1.pdf, 1p.pdf, ...)",
accept = ".zip"
)
)
)
),
numericInput(ns("max_i"), "Max index (N)", value = 9, min = 1, step = 1),
textInput(ns("outfile"), "Output filename", value = "TH3RESA_combined.pdf"),
actionButton(ns("preview"), "Preview order"),
br(), br(),
verbatimTextOutput(ns("order_preview")),
hr(),
withSpinner(downloadButton(ns("download"), "Download compiled PDF"))
)
}
pdf_compiler_server <- function(id) {
moduleServer(id, function(input, output, session) {
ns <- session$ns
shiny::validate(need(requireNamespace("qpdf", quietly = TRUE), "Package 'qpdf' is required."))
# Working dir for ZIP uploads
workdir <- reactiveVal(NULL)
observeEvent(input$zipfile, {
req(input$zipfile)
tmpdir <- tempfile("pdfzip_")
dir.create(tmpdir, recursive = TRUE, showWarnings = FALSE)
utils::unzip(input$zipfile$datapath, exdir = tmpdir)
workdir(tmpdir)
}, ignoreInit = TRUE)
# Resolve actual source directory
source_dir <- reactive({
if (input$source_mode == "folder") {
req(nzchar(input$pdf_dir))
return(normalizePath(input$pdf_dir, winslash = "/",
mustWork = FALSE)) # may reside on server
} else {
req(workdir())
return(workdir())
}
})
# Build ordered file list
build_order <- function(dir_path, N) {
stopifnot(is.numeric(N), N >= 1)
ordered_files <- character(0)
# Cover
cover <- file.path(dir_path, "0.pdf")
if (file.exists(cover)) ordered_files <- c(ordered_files, cover)
# 1..N (i.pdf then i p.pdf)
for (i in seq_len(N)) {
one_pager  <- file.path(dir_path, sprintf("%d.pdf", i))
publication <- file.path(dir_path, sprintf("%dp.pdf", i))
if (file.exists(one_pager))   ordered_files <- c(ordered_files, one_pager)
if (file.exists(publication)) ordered_files <- c(ordered_files, publication)
}
unique(ordered_files)
}
files_ordered <- eventReactive(input$preview, {
dir_path <- source_dir()
shiny::validate(need(dir.exists(dir_path), sprintf("Directory not found: %s", dir_path)))
ord <- build_order(dir_path, input$max_i)
shiny::validate(need(length(ord) > 0, "No matching PDFs found."))
ord
}, ignoreInit = TRUE)
output$order_preview <- renderText({
req(files_ordered())
rel <- gsub(paste0("^", gsub("\\\\", "\\\\\\\\", source_dir())), ".", files_ordered())
paste0("File count: ", length(rel), "\n\nOrder:\n", paste(rel, collapse = "\n"))
})
# Compile and provide download
output$download <- downloadHandler(
filename = function() {
nm <- input$outfile
if (!grepl("\\.pdf$", nm, ignore.case = TRUE)) nm <- paste0(nm, ".pdf")
nm
},
content = function(file) {
ord <- if (!is.null(isolate(files_ordered()))) {
isolate(files_ordered())
} else {
# compile without preview if user clicks download first
dir_path <- source_dir()
shiny::validate(need(dir.exists(dir_path), sprintf("Directory not found: %s", dir_path)))
tmp <- build_order(dir_path, input$max_i)
shiny::validate(need(length(tmp) > 0, "No matching PDFs found."))
tmp
}
# qpdf combine needs readable file list
withProgress(message = "Combining PDFs...", value = 0, {
incProgress(0.6)
qpdf::pdf_combine(input = ord, output = file)
incProgress(1)
})
}
)
})
}
library(shiny)
library(bslib)
library(here)
library(shinycssloaders)
library(shinycssloaders)
install.packages("shinycssloaders")
library(shinycssloaders)
source("modules/nct_update.R")
# Load modular UIs and servers
source("modules/nct_update.R")
source("modules/nct_update.R")
library(shiny)
library(bslib)
library(here)
library(shinycssloaders)
# Load modular UIs and servers
source("modules/nct_update.R")
# Server
server <- function(input, output, session) {
nct_server("nct")
veeva_server("veeva")
doiCheckerServer("doi")
coming_soon_server("coming")
pdf_compiler_server("pdfc")
}
ui <- fluidPage(
theme = bs_theme(bootswatch = "cosmo"),
titlePanel("Clinical Tools Portal"),
tabsetPanel(
type = "tabs",
tabPanel("NCT Update", nct_ui("nct")),
tabPanel("Veeva Resource Update", veeva_ui("veeva")),
tabPanel("DOI Checker", doiCheckerUI("doi")),
tabPanel("PDF Compiler", pdf_compiler_ui("pdfc")),
tabPanel("Coming Soon",   coming_soon_ui("coming"))
source("modules/nct_update.R")
# Run app
shinyApp(ui, server)
# UI with tabs
ui <- fluidPage(
theme = bs_theme(bootswatch = "cosmo"),
titlePanel("Clinical Tools Portal"),
tabsetPanel(
type = "tabs",
tabPanel("NCT Update", nct_ui("nct")),
tabPanel("Veeva Resource Update", veeva_ui("veeva")),
tabPanel("DOI Checker", doiCheckerUI("doi")),
tabPanel("PDF Compiler", pdf_compiler_ui("pdfc")),
tabPanel("Coming Soon",   coming_soon_ui("coming"))
)
)
setwd("C:/Users/Saurabh/OneDrive - Innomagine Consulting Private Limited/Desktop/TaskHelper Hub")
source("modules/nct_update.R")
source("modules/veeva_update.R")
source("modules/coming_soon.R")
source("Modules/DoiChecker.R")
source("modules/pdf_compiler.R")
# UI with tabs
ui <- fluidPage(
theme = bs_theme(bootswatch = "cosmo"),
titlePanel("Clinical Tools Portal"),
tabsetPanel(
type = "tabs",
tabPanel("NCT Update", nct_ui("nct")),
tabPanel("Veeva Resource Update", veeva_ui("veeva")),
tabPanel("DOI Checker", doiCheckerUI("doi")),
tabPanel("PDF Compiler", pdf_compiler_ui("pdfc")),
tabPanel("Coming Soon",   coming_soon_ui("coming"))
)
)
# Server
server <- function(input, output, session) {
nct_server("nct")
veeva_server("veeva")
doiCheckerServer("doi")
coming_soon_server("coming")
pdf_compiler_server("pdfc")
}
# Run app
shinyApp(ui, server)
reference_folder_ui <- function(id) {
ns <- NS(id)
tagList(
h3("Reference folder"),
# Reference source
textInput(
ns("ref_dir"),
"Reference folder (where PDFs are stored):",
value = "C:/Users/Saurabh/OneDrive - Innomagine Consulting Private Limited/00 References full text articles",
placeholder = "Absolute path, e.g. C:/path/to/reference"
),
helpText("Files are expected like 2901.pdf, 2903.pdf. If present, paired 2901p.pdf, 2903p.pdf will also be used."),
# IDs
textInput(
ns("ids"),
"IDs (comma or space separated):",
placeholder = "e.g., 2901, 2903, 2910"
),
checkboxInput(ns("include_paired"), "Include paired 'p' files (e.g., 2901p.pdf)", value = TRUE),
actionButton(ns("preview"), "Preview found / missing"),
br(), br(),
uiOutput(ns("preview_summary")),
tableOutput(ns("preview_table")),
tags$hr(),
# Option 1: Copy to folder
h4("Option 1 — Copy into a single folder"),
textInput(
ns("target_dir"),
"Target folder (will be created if it doesn't exist):",
placeholder = "Absolute path, e.g. C:/path/to/output/folder"
),
checkboxInput(ns("overwrite"), "Overwrite if file already exists in target", value = FALSE),
withSpinner(actionButton(ns("copy_btn"), "Copy PDFs")),
br(), uiOutput(ns("copy_result")),
tags$hr(),
# Option 2: Combine and download
h4("Option 2 — Combine into a single PDF"),
textInput(ns("outfile_name"), "Output filename:", value = "combined.pdf"),
withSpinner(downloadButton(ns("download_pdf"), "Download combined PDF"))
)
}
reference_folder_ui <- function(id) {
ns <- NS(id)
tagList(
h3("Reference folder"),
# Reference source
textInput(
ns("ref_dir"),
"Reference folder (where PDFs are stored):",
value = "C:/Users/Saurabh/OneDrive - Innomagine Consulting Private Limited/00 References full text articles",
placeholder = "Absolute path, e.g. C:/path/to/reference"
),
helpText("Files are expected like 2901.pdf, 2903.pdf. If present, paired 2901p.pdf, 2903p.pdf will also be used."),
# IDs
textInput(
ns("ids"),
"IDs (comma or space separated):",
placeholder = "e.g., 2901, 2903, 2910"
),
checkboxInput(ns("include_paired"), "Include paired 'p' files (e.g., 2901p.pdf)", value = TRUE),
actionButton(ns("preview"), "Preview found / missing"),
br(), br(),
uiOutput(ns("preview_summary")),
tableOutput(ns("preview_table")),
tags$hr(),
# Option 1: Copy to folder
h4("Option 1 — Copy into a single folder"),
textInput(
ns("target_dir"),
"Target folder (will be created if it doesn't exist):",
placeholder = "Absolute path, e.g. C:/path/to/output/folder"
),
checkboxInput(ns("overwrite"), "Overwrite if file already exists in target", value = FALSE),
withSpinner(actionButton(ns("copy_btn"), "Copy PDFs")),
br(), uiOutput(ns("copy_result")),
tags$hr(),
# Option 2: Combine and download
h4("Option 2 — Combine into a single PDF"),
textInput(ns("outfile_name"), "Output filename:", value = "combined.pdf"),
withSpinner(downloadButton(ns("download_pdf"), "Download combined PDF"))
)
}
reference_folder_server <- function(id) {
moduleServer(id, function(input, output, session) {
ns <- session$ns
# Ensure qpdf is available for combine
shiny::validate(need(requireNamespace("qpdf", quietly = TRUE),
"Package 'qpdf' is required. Install with install.packages('qpdf')."))
# Helpers ----
normalize_win <- function(path) {
if (!nzchar(path)) return(path)
# Accept both backslashes and slashes; normalize for R
tryCatch(normalizePath(path, winslash = "/", mustWork = FALSE),
error = function(e) path)
}
parse_ids <- function(txt) {
if (!nzchar(txt)) return(integer(0))
# keep digits, commas, spaces
clean <- gsub("[^0-9, ]", "", txt)
ids <- as.integer(unlist(strsplit(clean, "[, ]+")))
ids[!is.na(ids)]
}
build_candidates <- function(dir_path, ids, include_p = TRUE) {
# Return data.frame with expected filenames and status (exists or not)
if (!dir.exists(dir_path)) {
return(data.frame(
id = integer(0),
filename = character(0),
full_path = character(0),
exists = logical(0),
stringsAsFactors = FALSE
))
}
out <- list()
for (i in ids) {
main <- file.path(dir_path, sprintf("%d.pdf", i))
out[[length(out) + 1]] <- data.frame(
id = i,
filename = sprintf("%d.pdf", i),
full_path = main,
exists = file.exists(main),
stringsAsFactors = FALSE
)
if (isTRUE(include_p)) {
paired <- file.path(dir_path, sprintf("%dp.pdf", i))
out[[length(out) + 1]] <- data.frame(
id = i,
filename = sprintf("%dp.pdf", i),
full_path = paired,
exists = file.exists(paired),
stringsAsFactors = FALSE
)
}
}
do.call(rbind, out)
}
# Reactive: preview table of found/missing ----
preview_tbl <- eventReactive(input$preview, {
ref_dir <- normalize_win(input$ref_dir)
ids <- parse_ids(input$ids)
validate(
need(nzchar(ref_dir), "Please provide a Reference folder path."),
need(length(ids) > 0, "Please enter at least one ID.")
)
if (!dir.exists(ref_dir)) {
return(data.frame(
id = NA_integer_, filename = NA_character_, full_path = ref_dir,
exists = FALSE, stringsAsFactors = FALSE
))
}
build_candidates(ref_dir, ids, include_p = isTRUE(input$include_paired))
}, ignoreInit = TRUE)
output$preview_table <- renderTable({
tbl <- preview_tbl()
req(nrow(tbl) > 0)
data.frame(
ID = tbl$id,
File = tbl$filename,
Exists = ifelse(tbl$exists, "Available", "Not available"),
stringsAsFactors = FALSE
)
})
output$preview_summary <- renderUI({
tbl <- preview_tbl()
req(nrow(tbl) > 0)
if (!all(is.finite(tbl$id))) {
return(tags$div(class = "text-danger",
"Directory not found: ", strong(tbl$full_path[1])))
}
n_total <- nrow(tbl)
n_found <- sum(tbl$exists)
n_missing <- n_total - n_found
tags$div(
sprintf("Total files requested: %d | Available: %d | Missing: %d", n_total, n_found, n_missing),
if (n_missing > 0) tags$div(class = "text-warning",
"Missing files will be skipped; operations continue for available files.")
)
})
# Option 1: Copy files ----
observeEvent(input$copy_btn, {
req(preview_tbl())
ref_dir <- normalize_win(input$ref_dir)
target <- normalize_win(input$target_dir)
validate(
need(nzchar(target), "Please enter a Target folder path.")
)
if (!dir.exists(target)) {
dir.create(target, recursive = TRUE, showWarnings = FALSE)
}
tbl <- preview_tbl()
existing <- tbl[tbl$exists, , drop = FALSE]
missing  <- tbl[!tbl$exists, , drop = FALSE]
copied <- logical(0)
msgs <- character(0)
if (nrow(existing) > 0) {
for (i in seq_len(nrow(existing))) {
src <- existing$full_path[i]
dst <- file.path(target, basename(src))
ok <- file.copy(src, dst, overwrite = isTRUE(input$overwrite))
copied <- c(copied, ok)
msgs   <- c(msgs, sprintf("%s → %s [%s]",
basename(src), target, ifelse(ok, "copied", "skipped")))
}
}
out_html <- tagList(
tags$p(strong("Copy summary")),
tags$ul(lapply(msgs, tags$li))
)
if (nrow(missing) > 0) {
miss_list <- lapply(seq_len(nrow(missing)), function(i) {
tags$li(sprintf("%s — Not available", missing$filename[i]))
})
out_html <- tagAppendChildren(
out_html,
tags$p(class = "text-warning", strong("Missing files")),
tags$ul(miss_list)
)
}
output$copy_result <- renderUI(out_html)
}, ignoreInit = TRUE)
# Option 2: Combine & download ----
# Build ordered list of existing files at time of download
build_existing_order <- reactive({
tbl <- preview_tbl()
req(nrow(tbl) > 0)
# Keep only existing ones, preserve order in preview_tbl()
tbl$full_path[tbl$exists]
})
output$download_pdf <- downloadHandler(
filename = function() {
nm <- input$outfile_name
if (!grepl("\\.pdf$", nm, ignore.case = TRUE)) nm <- paste0(nm, ".pdf")
nm
},
content = function(file) {
ord <- build_existing_order()
validate(need(length(ord) > 0, "No available PDFs to combine."))
# Combine
qpdf::pdf_combine(input = ord, output = file)
}
)
})
}
source("modules/reference_folder.R")
# UI with tabs
ui <- fluidPage(
theme = bs_theme(bootswatch = "cosmo"),
titlePanel("Clinical Tools Portal"),
tabsetPanel(
type = "tabs",
tabPanel("NCT Update", nct_ui("nct")),
tabPanel("Veeva Resource Update", veeva_ui("veeva")),
tabPanel("DOI Checker", doiCheckerUI("doi")),
tabPanel("PDF Compiler", pdf_compiler_ui("pdfc")),
tabPanel("Reference folder", reference_folder_ui("refmod")),
tabPanel("Coming Soon",   coming_soon_ui("coming"))
)
)
source("modules/nct_update.R")
source("modules/veeva_update.R")
source("modules/coming_soon.R")
source("Modules/DoiChecker.R")
source("modules/pdf_compiler.R")
source("modules/reference_folder.R")
source("modules/nct_update.R")
source("modules/veeva_update.R")
source("modules/coming_soon.R")
source("Modules/DoiChecker.R")
source("modules/pdf_compiler.R")
source("modules/reference_folder.R")
# Load modular UIs and servers
source("modules/nct_update.R")
source("modules/veeva_update.R")
source("modules/nct_update.R")
source("modules/veeva_update.R")
source("modules/coming_soon.R")
source("Modules/DoiChecker.R")
source("modules/pdf_compiler.R")
source("modules/reference_folder.R")
# UI with tabs
ui <- fluidPage(
theme = bs_theme(bootswatch = "cosmo"),
titlePanel("Clinical Tools Portal"),
tabsetPanel(
type = "tabs",
tabPanel("NCT Update", nct_ui("nct")),
tabPanel("Veeva Resource Update", veeva_ui("veeva")),
tabPanel("DOI Checker", doiCheckerUI("doi")),
tabPanel("PDF Compiler", pdf_compiler_ui("pdfc")),
tabPanel("Reference folder", reference_folder_ui("refmod")),
tabPanel("Coming Soon",   coming_soon_ui("coming"))
)
)
# Server
server <- function(input, output, session) {
nct_server("nct")
veeva_server("veeva")
doiCheckerServer("doi")
coming_soon_server("coming")
pdf_compiler_server("pdfc")
reference_folder_server("refmod")
}
# Run app
shinyApp(ui, server)
